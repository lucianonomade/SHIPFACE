
import { NextRequest, NextResponse } from "next/server";
import { Octokit } from "@octokit/rest";
import Groq from "groq-sdk";
import { PROMPTS } from "@/lib/prompts";
import crypto from "crypto";

const groq = new Groq({
    apiKey: process.env.GROQ_API_KEY || "",
});

export async function POST(req: NextRequest) {
    try {
        const body = await req.json();
        const { repoFullName, filePath, issueDescription, githubToken, currentCode } = body;

        if (!repoFullName || !filePath || !issueDescription || !githubToken) {
            return NextResponse.json({ error: "Missing required fields" }, { status: 400 });
        }

        const [owner, repo] = repoFullName.split("/");
        const octokit = new Octokit({ auth: githubToken });

        // 1. Fetch file content if not provided
        let codeToFix = currentCode;
        let fileSha = "";

        if (!codeToFix) {
            try {
                const { data } = await octokit.repos.getContent({
                    owner,
                    repo,
                    path: filePath,
                });

                if (!Array.isArray(data) && data.type === "file" && data.content) {
                    codeToFix = Buffer.from(data.content, "base64").toString("utf-8");
                    fileSha = data.sha;
                } else {
                    throw new Error("Target is not a file");
                }
            } catch (e: any) {
                return NextResponse.json({ error: "Failed to fetch file content" }, { status: 404 });
            }
        } else {
            // We still need the SHA for the update
            try {
                const { data } = await octokit.repos.getContent({
                    owner,
                    repo,
                    path: filePath,
                });
                if (!Array.isArray(data)) {
                    fileSha = data.sha;
                }
            } catch (e) {
                // Ignore if fetching SHA fails if we rely on provided code, but commit will fail.
                // Ideally we always fetch to get the SHA.
            }
        }

        // 2. Generate Patch with AI
        const completion = await groq.chat.completions.create({
            model: "llama-3.3-70b-versatile",
            messages: [
                { role: "system", content: PROMPTS.PATCH_GENERATOR },
                { role: "user", content: `Vulnerability: ${issueDescription}\n\nCode:\n${codeToFix}` }
            ],
        });

        const fixedCode = completion.choices[0].message.content;

        if (!fixedCode || fixedCode.includes("UNABLE_TO_FIX")) {
            return NextResponse.json({ error: "AI could not generate a confident fix" }, { status: 422 });
        }

        // Clean up markdown code blocks if present
        const cleanFixedCode = fixedCode.replace(/^```[a-z]*\n/i, '').replace(/\n```$/, '');

        // 3. Create Branch
        const patchId = crypto.randomUUID().split("-")[0];
        const branchName = `patch/security-fix-${patchId}`;
        const baseBranch = "main"; // Defaulting to main, ideally detect default branch

        // Get ref of base branch logic
        let baseSha = "";
        try {
            const { data: repoData } = await octokit.repos.get({ owner, repo });
            const defaultBranch = repoData.default_branch;
            const { data: refData } = await octokit.git.getRef({
                owner,
                repo,
                ref: `heads/${defaultBranch}`,
            });
            baseSha = refData.object.sha;
        } catch (e) {
            return NextResponse.json({ error: "Failed to resolve default branch" }, { status: 500 });
        }

        // Create new Reference
        await octokit.git.createRef({
            owner,
            repo,
            ref: `refs/heads/${branchName}`,
            sha: baseSha,
        });

        // 4. Commit Changes
        await octokit.repos.createOrUpdateFileContents({
            owner,
            repo,
            path: filePath,
            message: `refactor(security): fix vulnerability in ${filePath} - ${issueDescription.substring(0, 50)}...`,
            content: Buffer.from(cleanFixedCode).toString("base64"),
            branch: branchName,
            sha: fileSha, // Required for update
        });

        // 5. Create Pull Request
        const { data: pr } = await octokit.pulls.create({
            owner,
            repo,
            title: `ðŸ›¡ï¸ Security Fix: ${issueDescription.substring(0, 50)}...`,
            body: `
## Neural Patch Auto-Remediation

**Vulnerability Detected:**
> ${issueDescription}

**Proposed Fix:**
The AI has analyzed the vulnerable code and generated a secure replacement.
Please review the changes carefully before merging.

*Generated by ShipSafe Neural Engine*
            `,
            head: branchName,
            base: "main", // or repoData.default_branch
        });

        return NextResponse.json({
            success: true,
            prUrl: pr.html_url,
            branch: branchName
        });

    } catch (error: any) {
        console.error("Patch Error:", error);
        return NextResponse.json({ error: error.message || "Failed to create patch" }, { status: 500 });
    }
}
